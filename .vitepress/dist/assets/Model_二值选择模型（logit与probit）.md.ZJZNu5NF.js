import{_ as e,c as o,a,l as t,a1 as i,o as r}from"./chunks/framework.ZVjbeeCo.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Model/二值选择模型（logit与probit）.md","filePath":"Model/二值选择模型（logit与probit）.md"}'),l={name:"Model/二值选择模型（logit与probit）.md"},p=t("h2",{id:"【离散变量】二值选择模型-logit与probit",tabindex:"-1"},[a("【离散变量】二值选择模型（logit与probit） "),t("a",{class:"header-anchor",href:"#【离散变量】二值选择模型-logit与probit","aria-label":'Permalink to "【离散变量】二值选择模型（logit与probit）"'},"​")],-1),s=t("div",{style:{"text-align":"center"}},[t("div",{style:{border:"2px solid #ccc",padding:"10px",display:"inline-block"}},[t("iframe",{src:"//player.bilibili.com/player.html?bvid=BV1x741137ef&page=1",scrolling:"no",border:"0",frameborder:"no",framespacing:"0",allowfullscreen:"true",style:{width:"750px",height:"450px"}})])],-1),c=i('<h2 id="二值选择模型" tabindex="-1">二值选择模型 <a class="header-anchor" href="#二值选择模型" aria-label="Permalink to &quot;二值选择模型&quot;">​</a></h2><p>对于二值选择模型，我们仍然可以沿用原有的思路，使用OLS（Ordinary Least Squares，最小二乘法）来进行拟合。然而，如果我们使用OLS，我们就会给它起一个名字，称为线性概率模型。</p><p>我们可以看到，y只能取0或1的值，而x则是一个连续的变量。如果我们使用一条直线来拟合这种情况，虽然可以拟合出一条直线，但会出现一个问题，即在x较小的情况下，y可能小于0，而在x较大的情况下，y可能大于1。这会导致一个奇怪的情况，即我们的现实生活数据中根本没有出现小于0或大于1的情况，因为y只能取0或1。</p><p>另一个问题是，我们前面的视频中提到的异方差问题。首先，很明显y服从两点分布会使得随机扰动项也会服从两点分布。</p><p>线性概率模型的优点是，系数很好解释。例如，如果我们拟合出一条线之后，β系数的含义非常清楚，即增大一个单位的x对这个事件发生概率的提升程度。</p><p>为了解决这些缺点，我们需要想办法进行修复。Probit和Logit模型的主要目的是想办法使得拟合线的值不会大于0、小于0或大于1。我们可以假设这条曲线在x无限小的情况下趋向0，在x较大的情况下趋向1。然后，我们对这条曲线做出一些假设，如果我们假设它的累积分布函数（CDF）类似标准正态分布，那么它就是一个Probit模型。如果我们假设它服从Logistic分布，那么它就是一个Logit模型。这只是一个简单的区别。</p><p>大多数情况下，人们会选择Logit模型，因为它有明确的表达式，而Probit模型则没有明确的表达式。此外，Logit模型比较好计算，因为它没有积分号，看起来更舒服。</p><h2 id="最大自然估计" tabindex="-1">最大自然估计 <a class="header-anchor" href="#最大自然估计" aria-label="Permalink to &quot;最大自然估计&quot;">​</a></h2><p>由于我们假设了CDF，因此我们的估计方法也会有所不同。我们将使用最大自然估计，而不是最小二乘法。最大自然估计的基本逻辑是，我们看到了样本，然后我们去猜测原来的分布最有可能是哪种分布。</p><p>例如，如果我们抛了10次硬币，并且看到5次正面和5次反面，我们可以大概率地推断，这个硬币的分布是均匀的，因为只有在这种情况下，我们才能得到这样的结果。如果我们看到500次硬币，其中70%是正面，30%是反面，我们可能会认为这个硬币的分布不是均匀的。</p><p>最大自然估计的基本逻辑是，我们假设x可能来自于哪种分布，然后使用现有的样本来估计这个分布的参数，使得现在的样本出现的可能性最大。对于二值选择，我们假设它服从Probit的CDF或Logistic的CDF，然后使用最大自然估计来估计原有的参数。</p><h2 id="在stata中的实现" tabindex="-1">在Stata中的实现 <a class="header-anchor" href="#在stata中的实现" aria-label="Permalink to &quot;在Stata中的实现&quot;">​</a></h2><p>在Stata中，实现这一点非常简单。我们只需输入probit或logit命令，然后将y和x输入进去，就可以解决问题了。我们还可以使用nolog选项，让下一次回归不报告迭代过程，并使用vce-robust选项解决一方差问题。这是在Stata中实现这一点的基本方法。</p><p>关于Stata的实现，命令已经写好了，非常简单。只需输入probit或logit命令，然后将y和x输入进去，就可以解决问题了。然后，我们可以讨论一下nolog选项。首先，我们可以看一下标准情况，即我们没有添加任何选项的情况。如果我们只输入probit命令，它会报告迭代的状况，并进行参数检验，大家应该都很熟悉了。lowlog选项让我们的下一次回归不报告交互项，因为我们不想让它出现在我们的回归界面上。vce-robust选项是在解决异方差问题时使用异方差稳健标准误。</p><p>这就是在Stata中实现二值选择模型的基本方法。</p><hr>',16);function n(d,_,b,h,g,x){return r(),o("div",null,[p,s,a(" 今天，我们要分享的主题是，当我们的模型中，或被解释变量是离散的时候，该如何进行处理。离散被解释变量可以有许多例子，例如选择一个人是否做某事，或选择使用哪种交通工具，如飞机、轮船或潜水艇。对于一些技术模型，我们可能会统计一些数量，但是由于专利数量等因素，我们可能无法获得连续的数据。 "),c])}const u=e(l,[["render",n]]);export{f as __pageData,u as default};
